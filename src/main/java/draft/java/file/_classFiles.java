package draft.java.file;

import draft.DraftException;

import java.net.URISyntaxException;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * In memory virtual "directory" to store {@link _classFile}(s) and
 * {@link Package}(s) generated by the Runtime Javac compiler
 * (as apposed to writing the ".class" file bytecodes to the
 * local file system)
 *
 * NOTE: classFiles have a 1-to-1 relationship with Java Runtime Class
 * (i.e. a single .java file can be compiled into separate .class files
 * because each nested class is represented in a separate .class file)
 */
public final class _classFiles{

    /**
     * Maps the class NAME to the _classFile
     * NOTE: Nested classes are stored
     * in unique files (i.e. the nested interface java.util.Map.Entry is
     * stored in by NAME "java.util.Map$Entry"
     */
    private final Map<String, _classFile> nameTo_classFile = new TreeMap<>();

    /** Packages defined in an _classFiles Manner for housing the _classFiles*/
    private final Map<String, Package> nameToPackage  = new TreeMap<>();

    /** Open _classFiles accept classes/ packages to be added */
    private final AtomicBoolean isOpen;

    public static _classFiles of( List<_classFile> _cfs ){
        _classFiles _ccfs = new _classFiles();
        _cfs.forEach( cf -> _ccfs.add( cf ) );
        return _ccfs;
    }

    public static _classFiles of( _classFile..._cfs ){
        _classFiles _ccfs = new _classFiles();
        Arrays.stream( _cfs ).forEach( cf -> _ccfs.add( cf ) );
        return _ccfs;
    }

    public _classFiles(){
        this.isOpen = new AtomicBoolean( true );
    }

    public _classFiles( _classFiles _prototype ) {
        this.isOpen = new AtomicBoolean( _prototype.isOpen.get() );

        this.nameToPackage.putAll( _prototype.nameToPackage );

        String[] keys
                = _prototype.nameTo_classFile.keySet().toArray( new String[ 0 ] );

        for( int i = 0; i < keys.length; i++ ) {
            this.nameTo_classFile.put(
                    keys[ i ],
                    _prototype.nameTo_classFile.get( keys[ i ] ) );
        }
    }

    public _classFiles open(){
        this.isOpen.set( true );
        return this;
    }

    public _classFiles close(){
        this.isOpen.set( false );
        return this;
    }

    /**
     * return whether the classFiles is open (for additions, etc.)
     * @return if this classFiles is open for specific (mutating) operations
     */
    public boolean isOpen(){
        return this.isOpen.get();
    }

    public _classFiles add(_classFiles _cfs ){
        //add all packages that we don't already have
        _cfs.nameToPackage.keySet().forEach( n -> {
            if( !this.nameToPackage.containsKey( n ) ){
                this.addPackage(_cfs.nameToPackage.get(n));
            }
        });
        //add all class
        _cfs.nameTo_classFile.values().forEach( n -> add( n) );
        return this;
    }

    public _classFiles add(_classFile _clf ){
        if( !isOpen.get() ){
            throw new DraftException("CLOSED, Cannot accept/load class files ");
        }
        _classFile _found = this.nameTo_classFile.get( _clf.getFullyQualifiedTypeName() );
        if( _found != null ){
            //LOG.info( "replacing _classFile \"" + _found.getFullName() + "\"");
        }
        this.nameTo_classFile.put( _clf.getFullyQualifiedTypeName(), _clf );
        return this;
    }

    /**
     * Create and Reserve/Bind a {@link _classFile} to write to given the NAME
     * of the class
     * THIS SHOULD ONLY BE USED BY the _classLoader during compilation
     * (NOT A USER LEVEL API)
     * When a _classFile doesn't exist yet for a source file that is being
     * compiled and the _compiler tries to find a place to write the bytes to,
     * we need to reserve a new _classFile in this directory by NAME,
     * (associate it with the nameTo_classFile  and return it for the javac
     * compiler to write to)
     *
     * @param fullClassName the full NAME of the class to be initiated (i.e. "java.util.Map")
     * @return a new {@link _classFile} (associated by NAME)
     */
    public _classFile reserve(String fullClassName ){
        if( !isOpen.get() ){
            throw new DraftException( "CLOSED, Cannot reserve class files");
        }
        try {
            //System.out.println( "create and bind "+ fullClassName + " from "+this.nameTo_classFile);
            _classFile _clf = _classFile.of(fullClassName);
            //_classFile _clf = new _classFile( fullClassName );

            // AT THIS TIME, I AM ADDING THIS BEFORE THE FILE IS WRITTEN,
            // I SHOULD (INSTEAD) WAIT UNTIL THE OUTPUTSTREAM IS CLOSED
            // AND THEN ADD IT
            this.nameTo_classFile.put( _clf.getFullyQualifiedTypeName(), _clf );
            return _clf;
        }
        catch( IllegalArgumentException ex ) {
            throw new DraftException(
                    "Can't create _classFile \""+fullClassName+"\" ", ex);
        }
        //catch( URISyntaxException ex ) {
        //    throw new DraftException(
        //            "Can't create _classFile \""+fullClassName+"\" ", ex);
        //}
    }

    /**
     * returns an ORDERED, UNIQUE listAt  of the package names
     * (INCLUDING "" if there are classes that are within the "root" package)
     * NOTE: the package Names in this of may have a different count
     * than the result of the listPackages() method
     *
     * @return an ordered list
     */
    public List<String> listPackageNames() {
        TreeSet<String> packageNames = new TreeSet<>();
        List<_classFile> _cfs = list();
        for( int i = 0; i < _cfs.size(); i++ ) {
            packageNames.add( _cfs.get( i ).getPackageName().replace( "/", "." ) );
        }
        List<String> list = new ArrayList<>();
        list.addAll( packageNames );
        return list;
    }

    /**
     * adds a Package to the _classFiles
     * @param pkg
     * @return the updated _classFiles
     */
    public _classFiles addPackage(Package pkg ){
        //if( !isOpen.getAt() ){
        //    throw new UseException("CLOSED, Cannot accept Packages ");
        //}
        this.nameToPackage.put(pkg.getName(), pkg );
        return this;
    }

    /**
     *
     * @param pkgMatchFn
     * @return
     */
    public List<Package> listPackages(Predicate<Package>pkgMatchFn ){
        return this.nameToPackage.values()
            .stream().filter( pkgMatchFn ).collect( Collectors.toList());
    }

    /**
     * Gets a List of {@link Package}s
     * (i.e. packages that were "synthesized"
     * (i.e. the LOCAL packages NOT the Packages in loader/ancestor ClassLoader)
     * @return
     */
    public List<Package> listPackages() {
        return nameToPackage.values().stream().collect( Collectors.toList() );
    }

    /**
     * @param _classFileMatchFn function for matching _classFile(s) to return
     * @return _classFiles matched by _classFileMatchFn
     */
    public List<_classFile>list(Predicate<_classFile>_classFileMatchFn){
        return nameTo_classFile.values()
                .stream().filter(_classFileMatchFn).collect( Collectors.toList() );
    }

    /**
     * gets a list of classFiles by Package (without getting subpackages)
     * @param pkg
     * @return
     */
    public List<_classFile> list(Package pkg ) {
        return list(pkg.getName(), false );
    }

    /**
     * gets a list of _classFiles by package and optionally recurses through subpackages
     * @param pkg
     * @param includeSubPkgs
     * @return
     */
    public List<_classFile> list(Package pkg, boolean includeSubPkgs ) {
        return list( pkg.getName(), includeSubPkgs );
    }

    /**
     * gets of classFiles by Package NAME (without getting subpackages)
     * @param pkgName
     * @return
     */
    public List<_classFile> list(String pkgName ) {
        return list(pkgName, false );
    }

    /**
     * gets the Package object for this string
     * @param name
     * @return 
     */
    public Package getPackage( String name ){
        return this.nameToPackage.get( name );
    }

    /** @return a map of className -> {@link Package} */
    public Map<String,Package>mapNameToPackage(){
        Map<String,Package> mm = new TreeMap<>();
        mm.putAll( this.nameToPackage );
        return mm;
    }

    /** @return a Map between className -> {@link _classFile} */
    public Map<String, _classFile> mapNameTo_classFile(){
        Map<String,_classFile> cm = new TreeMap<>();
        cm.putAll( this.nameTo_classFile );
        return cm;
    }

    /**
     * Gets _classFiles by package and optionally recurses through
     * subpackages
     *
     * @param pkgName the NAME of the package
     * @param includeSubPkgs include subpackages
     * @return listAt of _classFile s
     */
    public List<_classFile> list(String pkgName, boolean includeSubPkgs ) {

        if( pkgName == null ) {
            pkgName = "";
        }
        pkgName = pkgName.replace( '/', '.' );
        List<_classFile> _classFilesByPackage = new ArrayList<>();
        String[] fullClassNames = listClassNames().toArray( new String[ 0 ] );

        for( int i = 0; i < fullClassNames.length; i++ ) {
            if( pkgName == null || pkgName.length() == 0 ) {
                if( includeSubPkgs ) { //they want of class files
                    _classFilesByPackage.add(
                            get( fullClassNames[ i ] ) );
                }
                else if( !fullClassNames[ i ].contains( "." ) ) {
                    _classFilesByPackage.add(
                            get( fullClassNames[ i ] ) );
                }
            }
            else if( fullClassNames[ i ].startsWith(pkgName )
                    && (includeSubPkgs
                    || !(fullClassNames[ i ].substring(pkgName.length() + 1 ).contains( "." ))) ) {

                _classFilesByPackage.add( get( fullClassNames[ i ] ) );
            }
        }
        return _classFilesByPackage;
    }

    /**
     * NOTE: *getAt* METHODS will only return _classFiles classes and NOT classes
     * from the loader ClassLoader
     *
     * @param className the fully qualified class NAME (i.e.
     * "java.util.Map")
     * @return the _classFile
     */
    public _classFile get(String className ) {
        return nameTo_classFile.get( className );
    }

    /**
     * Removes classes based on the names provided
     *
     * @param classNames the names of classes
     * @return
     */
    public List<_classFile> remove(List<String> classNames ) {
        if( !this.isOpen.get( ) ){
            throw new DraftException("CLOSED, cannot removeAll "+classNames );
        }
        List<_classFile>removedFiles = new ArrayList<>();
        for(int i=0;i<classNames.size();i++){
            _classFile _clf = nameTo_classFile.remove( classNames.get(i).replace( '.', '/' ) );
            if( _clf != null ){
                //System.out.println( "removed "+ _clf.getFullName() );
                removedFiles.add( _clf );
            }
        }
        return removedFiles;
    }

    /** @return true if are there no class files present */
    public boolean isEmpty(){
        return this.nameTo_classFile.isEmpty() && this.nameToPackage.isEmpty();
    }

    /**
     * count the number of classes in the classDirectory (NOTE: inner classes
     * are counted as well)
     * @return
     */
    public int size(){
        return this.nameTo_classFile.size();
    }

    /**
     * Returns a Collection of the _classFiles containing java bytecodes
     *
     * @return of _classFiles
     */
    public List<_classFile> list() {
        List<_classFile> all = new ArrayList<>();
        all.addAll( this.nameTo_classFile.values() );
        return all;
    }

    /**
     * Gets of names for _classFiles
     * NOTE: returns Nested Class names as well
     *
     * @return a List of of fully qualified Class Names in the ClassLoader
     */
    public List<String> listClassNames() {
        List<String> allClassNames = new ArrayList<>();
        String[] toAdd = nameTo_classFile.keySet().toArray( new String[ 0 ] );
        for( int i = 0; i < toAdd.length; i++ ) {
            allClassNames.add( toAdd[ i ].replace( '/', '.' ) );
        }
        return allClassNames;
    }

    @Override
    public String toString(){
        StringBuilder sb = new StringBuilder();
        sb.append( "Class Files (").append(this.nameTo_classFile.size()).append(")");
        if( this.isOpen.get() ){
            sb.append(" *OPEN* ");
        }
        sb.append(System.lineSeparator());
        TreeSet<String> alpha = new TreeSet<>();
        alpha.addAll( this.nameTo_classFile.keySet() );
        alpha.forEach( cn -> sb.append("    ").append(cn).append(".class").append(System.lineSeparator()));
        return sb.toString();
    }
}
